今早醒来，我心血来潮问我自己："为什么我们会觉得新技能这么难学呢？"

我认为不仅仅是因为我们需要付出艰苦地努力，还有一个原因是我们把大量时间花在了学习理论知识，却没有通过练习把知识转化为技能。以游泳为例，即使你花费几百个小时去看游泳的专业书籍，观看游泳教学视频，甚至和专业游泳教练交流，第一次下水，你还是会跟个石头一样沉下去😏

老话说得好，*经验大似学问*。不管你觉得自己对一门学科有多了解，都应该动手去做，把知识转化为真正的技能。为了让你达成这一目标，我在[第一章](第一章.md)和[第二章](第二章.md)中加入了练习。并且我保证，在未来的文章中，你会看到更多的练习🙂

好了，现在正式开始今天的内容。

到目前为止，你已经学会了如何解释两个整数相加或相减的算术表达式，如 "7 + 3 "或 "12 - 9"。今天，我将介绍如何解析（识别）和解释包含任意数量加减运算符的算术表达式，例如 "7 - 3 + 2 - 1"。
本文中的算术表达式可以用下面的语法图表示：

到目前为止，我们已经学习了如何解释如"7 + 3"和"12 + 9"一类的整数加减法表达式。今天，我们将学习如何解释四则运算表达式……中的加减法表达式，比如"7 - 3 + 2 - 1"（乘除法改日再说）。

理论上来说，四则运算表达式中的项出现的次数应该是不限次的，加减符号也是如此。如果我们用流程图来表示的话，大概如图所示：
![图3.1](3.1.png)

你可以随便写一个表达式（不要有乘除法和括号谢谢），它一定可以用上面这个图表达：
1. 第一个肯定是项，也就是图中的term；
2. 后面可能没有其他的运算，例如表达式"3"就只有一个项，也就是图中最上面的路线
3. 或者后面跟着其他运算，也就是会有运算符号和另一个项
4. 再然后后面可能没有其他运算，例如表达式"3 + 4"就只有两个项一个运算符
5. 当然也可能还有其他的运算，例如表达式"7 - 3 + 2 — 1"，就是走图中最下面的路线

上面这种流程图的专业名词叫**语法图**，所谓语法图，就是能够表达编程语言语法规则的图。

为什么要介绍这么个东西？主要有以下三个原因：
1. 语法图能以图形的方式准确直观地告诉读者，我们的编程语言支持哪些语法，不支持哪些语法。比如说，目前我们的解释器（计算器）仅能识别包含加减法的数学表达式。而别人看到这个语法图就知道，如果在项后面跟上一个乘法号，或者在表达式的开头给个加法号，我们的解释器都是无法进行解释的。
2. 语法图容易理解：你只要跟着图中的箭头走就行，有分叉的地方表示有多种可能，有回头的地方就表示有循环。
3. 最重要的原因是，语法图是编写解释器的重要一步。有了语法图，你几乎可以无脑地把它映射到你的代码中，完成语义解析的工作。

前面我们介绍到，在token流中识别短语的过程叫做**解析**。在解释器中，负责这部分工作的模块叫做**解析器（Parser）**。实际上解析又被叫做**语法分析**，因为它做的事就是在分析语法是否符合预期。那么同理，解析器也可以叫做**语法分析器**。

因为每个编程语言的算术表达式的语法都是类似的，所以你可以暂时在Python中"测试"一下我们的语法图。在命令行里面启动Python，然后自己写几个符合我们语法图的数学表达式：
```shell
>>> 3
3
>>> 3 + 4
7
>>> 7 - 3 + 2 - 1
5
```

嗯，Python同学算得不错。

算术式"3+"不是一个合法的数学表达式，因为按照语法图（图3.1）的语法来看，加法号后面应该紧跟着一个项，否则就是语法错误。在Ptyon中测试一下，你也可以看到关于语法错误的提示：
```shell
>>> 3 +
  File "<stdin>", line 1
    3 +
      ^
SyntaxError: invalid syntax
```

用Python来进行测试固然很爽，但毕竟不是我们的目的。接下来，我们就把语法图转化为代码，然后用我们自己的解释器来进行测试，期待一下吧！😼

在前面的文章里（[第一章](第一章.md)与[第二章](第二章.md)），`expr`函数既是解析器也是解释器，因为它要先从token流中解析出特定的语法（解析器），然后再根据语法解释出最终的结果（解释器）。

下面的代码片段展示了语法图对应的代码。为了能和语法图一一对应，我们用`term`函数来负责term矩形框中的工作：解析整数。而`expr`函数则仅负责执行语法图的主流程：
```python
def term(self):
    self.eat(INTEGER)

def expr(self):
    # set current token to the first token taken from the input
    # 将当前token设置为从输入解析出的第一个token
    self.current_token = self.get_next_token()

    self.term()
    while self.current_token.type in (PLUS, MINUS):
        token = self.current_token
        if token.type == PLUS:
            self.eat(PLUS)
            self.term()
        elif token.type == MINUS:
            self.eat(MINUS)
            self.term()
```

